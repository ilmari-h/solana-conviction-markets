/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getDiscriminatedUnionDecoder,
  getDiscriminatedUnionEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getTupleDecoder,
  getTupleEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getActivationDecoder,
  getActivationEncoder,
  getBN254G2BLSPublicKeyDecoder,
  getBN254G2BLSPublicKeyEncoder,
  getEpochDecoder,
  getEpochEncoder,
  getNodeMetadataDecoder,
  getNodeMetadataEncoder,
  getNodeRefDecoder,
  getNodeRefEncoder,
  type Activation,
  type ActivationArgs,
  type BN254G2BLSPublicKey,
  type BN254G2BLSPublicKeyArgs,
  type Epoch,
  type EpochArgs,
  type NodeMetadata,
  type NodeMetadataArgs,
  type NodeRef,
  type NodeRefArgs,
} from '../types';

export const CLUSTER_DISCRIMINATOR = new Uint8Array([
  236, 225, 118, 228, 173, 106, 18, 60,
]);

export function getClusterDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CLUSTER_DISCRIMINATOR);
}

export type Cluster = {
  discriminator: ReadonlyUint8Array;
  tdInfo: Option<NodeMetadata>;
  authority: Option<Address>;
  clusterSize: number;
  activation: Activation;
  maxCapacity: bigint;
  cuPrice: bigint;
  cuPriceProposals: Array<bigint>;
  lastUpdatedEpoch: Epoch;
  nodes: Array<NodeRef>;
  pendingNodes: Array<number>;
  blsPublicKey:
    | { __kind: 'Set'; fields: readonly [BN254G2BLSPublicKey] }
    | {
        __kind: 'Unset';
        fields: readonly [BN254G2BLSPublicKey, Array<boolean>];
      };
  bump: number;
};

export type ClusterArgs = {
  tdInfo: OptionOrNullable<NodeMetadataArgs>;
  authority: OptionOrNullable<Address>;
  clusterSize: number;
  activation: ActivationArgs;
  maxCapacity: number | bigint;
  cuPrice: number | bigint;
  cuPriceProposals: Array<number | bigint>;
  lastUpdatedEpoch: EpochArgs;
  nodes: Array<NodeRefArgs>;
  pendingNodes: Array<number>;
  blsPublicKey:
    | { __kind: 'Set'; fields: readonly [BN254G2BLSPublicKeyArgs] }
    | {
        __kind: 'Unset';
        fields: readonly [BN254G2BLSPublicKeyArgs, Array<boolean>];
      };
  bump: number;
};

export function getClusterEncoder(): Encoder<ClusterArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['tdInfo', getOptionEncoder(getNodeMetadataEncoder())],
      ['authority', getOptionEncoder(getAddressEncoder())],
      ['clusterSize', getU16Encoder()],
      ['activation', getActivationEncoder()],
      ['maxCapacity', getU64Encoder()],
      ['cuPrice', getU64Encoder()],
      ['cuPriceProposals', getArrayEncoder(getU64Encoder(), { size: 32 })],
      ['lastUpdatedEpoch', getEpochEncoder()],
      ['nodes', getArrayEncoder(getNodeRefEncoder())],
      ['pendingNodes', getArrayEncoder(getU32Encoder())],
      [
        'blsPublicKey',
        getDiscriminatedUnionEncoder([
          [
            'Set',
            getStructEncoder([
              ['fields', getTupleEncoder([getBN254G2BLSPublicKeyEncoder()])],
            ]),
          ],
          [
            'Unset',
            getStructEncoder([
              [
                'fields',
                getTupleEncoder([
                  getBN254G2BLSPublicKeyEncoder(),
                  getArrayEncoder(getBooleanEncoder()),
                ]),
              ],
            ]),
          ],
        ]),
      ],
      ['bump', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: CLUSTER_DISCRIMINATOR })
  );
}

export function getClusterDecoder(): Decoder<Cluster> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['tdInfo', getOptionDecoder(getNodeMetadataDecoder())],
    ['authority', getOptionDecoder(getAddressDecoder())],
    ['clusterSize', getU16Decoder()],
    ['activation', getActivationDecoder()],
    ['maxCapacity', getU64Decoder()],
    ['cuPrice', getU64Decoder()],
    ['cuPriceProposals', getArrayDecoder(getU64Decoder(), { size: 32 })],
    ['lastUpdatedEpoch', getEpochDecoder()],
    ['nodes', getArrayDecoder(getNodeRefDecoder())],
    ['pendingNodes', getArrayDecoder(getU32Decoder())],
    [
      'blsPublicKey',
      getDiscriminatedUnionDecoder([
        [
          'Set',
          getStructDecoder([
            ['fields', getTupleDecoder([getBN254G2BLSPublicKeyDecoder()])],
          ]),
        ],
        [
          'Unset',
          getStructDecoder([
            [
              'fields',
              getTupleDecoder([
                getBN254G2BLSPublicKeyDecoder(),
                getArrayDecoder(getBooleanDecoder()),
              ]),
            ],
          ]),
        ],
      ]),
    ],
    ['bump', getU8Decoder()],
  ]);
}

export function getClusterCodec(): Codec<ClusterArgs, Cluster> {
  return combineCodec(getClusterEncoder(), getClusterDecoder());
}

export function decodeCluster<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Cluster, TAddress>;
export function decodeCluster<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Cluster, TAddress>;
export function decodeCluster<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Cluster, TAddress> | MaybeAccount<Cluster, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getClusterDecoder()
  );
}

export async function fetchCluster<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Cluster, TAddress>> {
  const maybeAccount = await fetchMaybeCluster(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeCluster<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Cluster, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeCluster(maybeAccount);
}

export async function fetchAllCluster(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Cluster>[]> {
  const maybeAccounts = await fetchAllMaybeCluster(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeCluster(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Cluster>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeCluster(maybeAccount));
}
