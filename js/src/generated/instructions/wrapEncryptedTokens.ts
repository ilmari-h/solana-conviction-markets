/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { OPPORTUNITY_MARKET_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const WRAP_ENCRYPTED_TOKENS_DISCRIMINATOR = new Uint8Array([
  249, 160, 73, 35, 110, 134, 22, 106,
]);

export function getWrapEncryptedTokensDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    WRAP_ENCRYPTED_TOKENS_DISCRIMINATOR
  );
}

export type WrapEncryptedTokensInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountSigner extends string | AccountMeta<string> = string,
  TAccountTokenMint extends string | AccountMeta<string> = string,
  TAccountEncryptedTokenAccount extends string | AccountMeta<string> = string,
  TAccountSignerTokenAccount extends string | AccountMeta<string> = string,
  TAccountTokenVault extends string | AccountMeta<string> = string,
  TAccountTokenVaultAta extends string | AccountMeta<string> = string,
  TAccountSignPdaAccount extends string | AccountMeta<string> = string,
  TAccountMxeAccount extends string | AccountMeta<string> = string,
  TAccountMempoolAccount extends string | AccountMeta<string> = string,
  TAccountExecutingPool extends string | AccountMeta<string> = string,
  TAccountComputationAccount extends string | AccountMeta<string> = string,
  TAccountCompDefAccount extends string | AccountMeta<string> = string,
  TAccountClusterAccount extends string | AccountMeta<string> = string,
  TAccountPoolAccount extends string | AccountMeta<string> =
    'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC',
  TAccountClockAccount extends string | AccountMeta<string> =
    '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot',
  TAccountSystemProgram extends string | AccountMeta<string> =
    '11111111111111111111111111111111',
  TAccountTokenProgram extends string | AccountMeta<string> = string,
  TAccountArciumProgram extends string | AccountMeta<string> =
    'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountSigner extends string
        ? WritableSignerAccount<TAccountSigner> &
            AccountSignerMeta<TAccountSigner>
        : TAccountSigner,
      TAccountTokenMint extends string
        ? ReadonlyAccount<TAccountTokenMint>
        : TAccountTokenMint,
      TAccountEncryptedTokenAccount extends string
        ? WritableAccount<TAccountEncryptedTokenAccount>
        : TAccountEncryptedTokenAccount,
      TAccountSignerTokenAccount extends string
        ? WritableAccount<TAccountSignerTokenAccount>
        : TAccountSignerTokenAccount,
      TAccountTokenVault extends string
        ? ReadonlyAccount<TAccountTokenVault>
        : TAccountTokenVault,
      TAccountTokenVaultAta extends string
        ? WritableAccount<TAccountTokenVaultAta>
        : TAccountTokenVaultAta,
      TAccountSignPdaAccount extends string
        ? WritableAccount<TAccountSignPdaAccount>
        : TAccountSignPdaAccount,
      TAccountMxeAccount extends string
        ? ReadonlyAccount<TAccountMxeAccount>
        : TAccountMxeAccount,
      TAccountMempoolAccount extends string
        ? WritableAccount<TAccountMempoolAccount>
        : TAccountMempoolAccount,
      TAccountExecutingPool extends string
        ? WritableAccount<TAccountExecutingPool>
        : TAccountExecutingPool,
      TAccountComputationAccount extends string
        ? WritableAccount<TAccountComputationAccount>
        : TAccountComputationAccount,
      TAccountCompDefAccount extends string
        ? ReadonlyAccount<TAccountCompDefAccount>
        : TAccountCompDefAccount,
      TAccountClusterAccount extends string
        ? WritableAccount<TAccountClusterAccount>
        : TAccountClusterAccount,
      TAccountPoolAccount extends string
        ? WritableAccount<TAccountPoolAccount>
        : TAccountPoolAccount,
      TAccountClockAccount extends string
        ? WritableAccount<TAccountClockAccount>
        : TAccountClockAccount,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountArciumProgram extends string
        ? ReadonlyAccount<TAccountArciumProgram>
        : TAccountArciumProgram,
      ...TRemainingAccounts,
    ]
  >;

export type WrapEncryptedTokensInstructionData = {
  discriminator: ReadonlyUint8Array;
  computationOffset: bigint;
  amount: bigint;
};

export type WrapEncryptedTokensInstructionDataArgs = {
  computationOffset: number | bigint;
  amount: number | bigint;
};

export function getWrapEncryptedTokensInstructionDataEncoder(): FixedSizeEncoder<WrapEncryptedTokensInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['computationOffset', getU64Encoder()],
      ['amount', getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: WRAP_ENCRYPTED_TOKENS_DISCRIMINATOR,
    })
  );
}

export function getWrapEncryptedTokensInstructionDataDecoder(): FixedSizeDecoder<WrapEncryptedTokensInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['computationOffset', getU64Decoder()],
    ['amount', getU64Decoder()],
  ]);
}

export function getWrapEncryptedTokensInstructionDataCodec(): FixedSizeCodec<
  WrapEncryptedTokensInstructionDataArgs,
  WrapEncryptedTokensInstructionData
> {
  return combineCodec(
    getWrapEncryptedTokensInstructionDataEncoder(),
    getWrapEncryptedTokensInstructionDataDecoder()
  );
}

export type WrapEncryptedTokensAsyncInput<
  TAccountSigner extends string = string,
  TAccountTokenMint extends string = string,
  TAccountEncryptedTokenAccount extends string = string,
  TAccountSignerTokenAccount extends string = string,
  TAccountTokenVault extends string = string,
  TAccountTokenVaultAta extends string = string,
  TAccountSignPdaAccount extends string = string,
  TAccountMxeAccount extends string = string,
  TAccountMempoolAccount extends string = string,
  TAccountExecutingPool extends string = string,
  TAccountComputationAccount extends string = string,
  TAccountCompDefAccount extends string = string,
  TAccountClusterAccount extends string = string,
  TAccountPoolAccount extends string = string,
  TAccountClockAccount extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountArciumProgram extends string = string,
> = {
  signer: TransactionSigner<TAccountSigner>;
  tokenMint: Address<TAccountTokenMint>;
  encryptedTokenAccount: Address<TAccountEncryptedTokenAccount>;
  /** The signer's token account (source of SPL tokens) */
  signerTokenAccount: Address<TAccountSignerTokenAccount>;
  /** Token vault holding all wrapped tokens */
  tokenVault?: Address<TAccountTokenVault>;
  /** ATA owned by the TokenVault PDA (destination of SPL tokens) */
  tokenVaultAta?: Address<TAccountTokenVaultAta>;
  signPdaAccount?: Address<TAccountSignPdaAccount>;
  mxeAccount: Address<TAccountMxeAccount>;
  mempoolAccount: Address<TAccountMempoolAccount>;
  executingPool: Address<TAccountExecutingPool>;
  computationAccount: Address<TAccountComputationAccount>;
  compDefAccount: Address<TAccountCompDefAccount>;
  clusterAccount: Address<TAccountClusterAccount>;
  poolAccount?: Address<TAccountPoolAccount>;
  clockAccount?: Address<TAccountClockAccount>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram: Address<TAccountTokenProgram>;
  arciumProgram?: Address<TAccountArciumProgram>;
  computationOffset: WrapEncryptedTokensInstructionDataArgs['computationOffset'];
  amount: WrapEncryptedTokensInstructionDataArgs['amount'];
};

export async function getWrapEncryptedTokensInstructionAsync<
  TAccountSigner extends string,
  TAccountTokenMint extends string,
  TAccountEncryptedTokenAccount extends string,
  TAccountSignerTokenAccount extends string,
  TAccountTokenVault extends string,
  TAccountTokenVaultAta extends string,
  TAccountSignPdaAccount extends string,
  TAccountMxeAccount extends string,
  TAccountMempoolAccount extends string,
  TAccountExecutingPool extends string,
  TAccountComputationAccount extends string,
  TAccountCompDefAccount extends string,
  TAccountClusterAccount extends string,
  TAccountPoolAccount extends string,
  TAccountClockAccount extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TAccountArciumProgram extends string,
  TProgramAddress extends Address = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
>(
  input: WrapEncryptedTokensAsyncInput<
    TAccountSigner,
    TAccountTokenMint,
    TAccountEncryptedTokenAccount,
    TAccountSignerTokenAccount,
    TAccountTokenVault,
    TAccountTokenVaultAta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountArciumProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  WrapEncryptedTokensInstruction<
    TProgramAddress,
    TAccountSigner,
    TAccountTokenMint,
    TAccountEncryptedTokenAccount,
    TAccountSignerTokenAccount,
    TAccountTokenVault,
    TAccountTokenVaultAta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountArciumProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPPORTUNITY_MARKET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    signer: { value: input.signer ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    encryptedTokenAccount: {
      value: input.encryptedTokenAccount ?? null,
      isWritable: true,
    },
    signerTokenAccount: {
      value: input.signerTokenAccount ?? null,
      isWritable: true,
    },
    tokenVault: { value: input.tokenVault ?? null, isWritable: false },
    tokenVaultAta: { value: input.tokenVaultAta ?? null, isWritable: true },
    signPdaAccount: { value: input.signPdaAccount ?? null, isWritable: true },
    mxeAccount: { value: input.mxeAccount ?? null, isWritable: false },
    mempoolAccount: { value: input.mempoolAccount ?? null, isWritable: true },
    executingPool: { value: input.executingPool ?? null, isWritable: true },
    computationAccount: {
      value: input.computationAccount ?? null,
      isWritable: true,
    },
    compDefAccount: { value: input.compDefAccount ?? null, isWritable: false },
    clusterAccount: { value: input.clusterAccount ?? null, isWritable: true },
    poolAccount: { value: input.poolAccount ?? null, isWritable: true },
    clockAccount: { value: input.clockAccount ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    arciumProgram: { value: input.arciumProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenVault.value) {
    accounts.tokenVault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([116, 111, 107, 101, 110, 95, 118, 97, 117, 108, 116])
        ),
      ],
    });
  }
  if (!accounts.tokenVaultAta.value) {
    accounts.tokenVaultAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.tokenVault.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenMint.value)),
      ],
    });
  }
  if (!accounts.signPdaAccount.value) {
    accounts.signPdaAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            65, 114, 99, 105, 117, 109, 83, 105, 103, 110, 101, 114, 65, 99, 99,
            111, 117, 110, 116,
          ])
        ),
      ],
    });
  }
  if (!accounts.poolAccount.value) {
    accounts.poolAccount.value =
      'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC' as Address<'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC'>;
  }
  if (!accounts.clockAccount.value) {
    accounts.clockAccount.value =
      '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot' as Address<'7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.arciumProgram.value) {
    accounts.arciumProgram.value =
      'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ' as Address<'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.signer),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.encryptedTokenAccount),
      getAccountMeta(accounts.signerTokenAccount),
      getAccountMeta(accounts.tokenVault),
      getAccountMeta(accounts.tokenVaultAta),
      getAccountMeta(accounts.signPdaAccount),
      getAccountMeta(accounts.mxeAccount),
      getAccountMeta(accounts.mempoolAccount),
      getAccountMeta(accounts.executingPool),
      getAccountMeta(accounts.computationAccount),
      getAccountMeta(accounts.compDefAccount),
      getAccountMeta(accounts.clusterAccount),
      getAccountMeta(accounts.poolAccount),
      getAccountMeta(accounts.clockAccount),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.arciumProgram),
    ],
    data: getWrapEncryptedTokensInstructionDataEncoder().encode(
      args as WrapEncryptedTokensInstructionDataArgs
    ),
    programAddress,
  } as WrapEncryptedTokensInstruction<
    TProgramAddress,
    TAccountSigner,
    TAccountTokenMint,
    TAccountEncryptedTokenAccount,
    TAccountSignerTokenAccount,
    TAccountTokenVault,
    TAccountTokenVaultAta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountArciumProgram
  >);
}

export type WrapEncryptedTokensInput<
  TAccountSigner extends string = string,
  TAccountTokenMint extends string = string,
  TAccountEncryptedTokenAccount extends string = string,
  TAccountSignerTokenAccount extends string = string,
  TAccountTokenVault extends string = string,
  TAccountTokenVaultAta extends string = string,
  TAccountSignPdaAccount extends string = string,
  TAccountMxeAccount extends string = string,
  TAccountMempoolAccount extends string = string,
  TAccountExecutingPool extends string = string,
  TAccountComputationAccount extends string = string,
  TAccountCompDefAccount extends string = string,
  TAccountClusterAccount extends string = string,
  TAccountPoolAccount extends string = string,
  TAccountClockAccount extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountArciumProgram extends string = string,
> = {
  signer: TransactionSigner<TAccountSigner>;
  tokenMint: Address<TAccountTokenMint>;
  encryptedTokenAccount: Address<TAccountEncryptedTokenAccount>;
  /** The signer's token account (source of SPL tokens) */
  signerTokenAccount: Address<TAccountSignerTokenAccount>;
  /** Token vault holding all wrapped tokens */
  tokenVault: Address<TAccountTokenVault>;
  /** ATA owned by the TokenVault PDA (destination of SPL tokens) */
  tokenVaultAta: Address<TAccountTokenVaultAta>;
  signPdaAccount: Address<TAccountSignPdaAccount>;
  mxeAccount: Address<TAccountMxeAccount>;
  mempoolAccount: Address<TAccountMempoolAccount>;
  executingPool: Address<TAccountExecutingPool>;
  computationAccount: Address<TAccountComputationAccount>;
  compDefAccount: Address<TAccountCompDefAccount>;
  clusterAccount: Address<TAccountClusterAccount>;
  poolAccount?: Address<TAccountPoolAccount>;
  clockAccount?: Address<TAccountClockAccount>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram: Address<TAccountTokenProgram>;
  arciumProgram?: Address<TAccountArciumProgram>;
  computationOffset: WrapEncryptedTokensInstructionDataArgs['computationOffset'];
  amount: WrapEncryptedTokensInstructionDataArgs['amount'];
};

export function getWrapEncryptedTokensInstruction<
  TAccountSigner extends string,
  TAccountTokenMint extends string,
  TAccountEncryptedTokenAccount extends string,
  TAccountSignerTokenAccount extends string,
  TAccountTokenVault extends string,
  TAccountTokenVaultAta extends string,
  TAccountSignPdaAccount extends string,
  TAccountMxeAccount extends string,
  TAccountMempoolAccount extends string,
  TAccountExecutingPool extends string,
  TAccountComputationAccount extends string,
  TAccountCompDefAccount extends string,
  TAccountClusterAccount extends string,
  TAccountPoolAccount extends string,
  TAccountClockAccount extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TAccountArciumProgram extends string,
  TProgramAddress extends Address = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
>(
  input: WrapEncryptedTokensInput<
    TAccountSigner,
    TAccountTokenMint,
    TAccountEncryptedTokenAccount,
    TAccountSignerTokenAccount,
    TAccountTokenVault,
    TAccountTokenVaultAta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountArciumProgram
  >,
  config?: { programAddress?: TProgramAddress }
): WrapEncryptedTokensInstruction<
  TProgramAddress,
  TAccountSigner,
  TAccountTokenMint,
  TAccountEncryptedTokenAccount,
  TAccountSignerTokenAccount,
  TAccountTokenVault,
  TAccountTokenVaultAta,
  TAccountSignPdaAccount,
  TAccountMxeAccount,
  TAccountMempoolAccount,
  TAccountExecutingPool,
  TAccountComputationAccount,
  TAccountCompDefAccount,
  TAccountClusterAccount,
  TAccountPoolAccount,
  TAccountClockAccount,
  TAccountSystemProgram,
  TAccountTokenProgram,
  TAccountArciumProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPPORTUNITY_MARKET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    signer: { value: input.signer ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    encryptedTokenAccount: {
      value: input.encryptedTokenAccount ?? null,
      isWritable: true,
    },
    signerTokenAccount: {
      value: input.signerTokenAccount ?? null,
      isWritable: true,
    },
    tokenVault: { value: input.tokenVault ?? null, isWritable: false },
    tokenVaultAta: { value: input.tokenVaultAta ?? null, isWritable: true },
    signPdaAccount: { value: input.signPdaAccount ?? null, isWritable: true },
    mxeAccount: { value: input.mxeAccount ?? null, isWritable: false },
    mempoolAccount: { value: input.mempoolAccount ?? null, isWritable: true },
    executingPool: { value: input.executingPool ?? null, isWritable: true },
    computationAccount: {
      value: input.computationAccount ?? null,
      isWritable: true,
    },
    compDefAccount: { value: input.compDefAccount ?? null, isWritable: false },
    clusterAccount: { value: input.clusterAccount ?? null, isWritable: true },
    poolAccount: { value: input.poolAccount ?? null, isWritable: true },
    clockAccount: { value: input.clockAccount ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    arciumProgram: { value: input.arciumProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.poolAccount.value) {
    accounts.poolAccount.value =
      'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC' as Address<'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC'>;
  }
  if (!accounts.clockAccount.value) {
    accounts.clockAccount.value =
      '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot' as Address<'7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.arciumProgram.value) {
    accounts.arciumProgram.value =
      'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ' as Address<'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.signer),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.encryptedTokenAccount),
      getAccountMeta(accounts.signerTokenAccount),
      getAccountMeta(accounts.tokenVault),
      getAccountMeta(accounts.tokenVaultAta),
      getAccountMeta(accounts.signPdaAccount),
      getAccountMeta(accounts.mxeAccount),
      getAccountMeta(accounts.mempoolAccount),
      getAccountMeta(accounts.executingPool),
      getAccountMeta(accounts.computationAccount),
      getAccountMeta(accounts.compDefAccount),
      getAccountMeta(accounts.clusterAccount),
      getAccountMeta(accounts.poolAccount),
      getAccountMeta(accounts.clockAccount),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.arciumProgram),
    ],
    data: getWrapEncryptedTokensInstructionDataEncoder().encode(
      args as WrapEncryptedTokensInstructionDataArgs
    ),
    programAddress,
  } as WrapEncryptedTokensInstruction<
    TProgramAddress,
    TAccountSigner,
    TAccountTokenMint,
    TAccountEncryptedTokenAccount,
    TAccountSignerTokenAccount,
    TAccountTokenVault,
    TAccountTokenVaultAta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountArciumProgram
  >);
}

export type ParsedWrapEncryptedTokensInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    signer: TAccountMetas[0];
    tokenMint: TAccountMetas[1];
    encryptedTokenAccount: TAccountMetas[2];
    /** The signer's token account (source of SPL tokens) */
    signerTokenAccount: TAccountMetas[3];
    /** Token vault holding all wrapped tokens */
    tokenVault: TAccountMetas[4];
    /** ATA owned by the TokenVault PDA (destination of SPL tokens) */
    tokenVaultAta: TAccountMetas[5];
    signPdaAccount: TAccountMetas[6];
    mxeAccount: TAccountMetas[7];
    mempoolAccount: TAccountMetas[8];
    executingPool: TAccountMetas[9];
    computationAccount: TAccountMetas[10];
    compDefAccount: TAccountMetas[11];
    clusterAccount: TAccountMetas[12];
    poolAccount: TAccountMetas[13];
    clockAccount: TAccountMetas[14];
    systemProgram: TAccountMetas[15];
    tokenProgram: TAccountMetas[16];
    arciumProgram: TAccountMetas[17];
  };
  data: WrapEncryptedTokensInstructionData;
};

export function parseWrapEncryptedTokensInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedWrapEncryptedTokensInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 18) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      signer: getNextAccount(),
      tokenMint: getNextAccount(),
      encryptedTokenAccount: getNextAccount(),
      signerTokenAccount: getNextAccount(),
      tokenVault: getNextAccount(),
      tokenVaultAta: getNextAccount(),
      signPdaAccount: getNextAccount(),
      mxeAccount: getNextAccount(),
      mempoolAccount: getNextAccount(),
      executingPool: getNextAccount(),
      computationAccount: getNextAccount(),
      compDefAccount: getNextAccount(),
      clusterAccount: getNextAccount(),
      poolAccount: getNextAccount(),
      clockAccount: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      arciumProgram: getNextAccount(),
    },
    data: getWrapEncryptedTokensInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
