/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getDiscriminatedUnionDecoder,
  getDiscriminatedUnionEncoder,
  getStructDecoder,
  getStructEncoder,
  getTupleDecoder,
  getTupleEncoder,
  getU8Decoder,
  getU8Encoder,
  getUnitDecoder,
  getUnitEncoder,
  transformEncoder,
  type AccountMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type WritableAccount,
} from '@solana/kit';
import { OPPORTUNITY_MARKET_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getCloseEphemeralEncryptedTokenAccountOutputDecoder,
  getCloseEphemeralEncryptedTokenAccountOutputEncoder,
  type CloseEphemeralEncryptedTokenAccountOutput,
  type CloseEphemeralEncryptedTokenAccountOutputArgs,
} from '../types';

export const CLOSE_EPHEMERAL_ENCRYPTED_TOKEN_ACCOUNT_CALLBACK_DISCRIMINATOR =
  new Uint8Array([169, 52, 248, 50, 36, 66, 181, 9]);

export function getCloseEphemeralEncryptedTokenAccountCallbackDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLOSE_EPHEMERAL_ENCRYPTED_TOKEN_ACCOUNT_CALLBACK_DISCRIMINATOR
  );
}

export type CloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountArciumProgram extends string | AccountMeta<string> =
    'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ',
  TAccountCompDefAccount extends string | AccountMeta<string> = string,
  TAccountMxeAccount extends string | AccountMeta<string> = string,
  TAccountComputationAccount extends string | AccountMeta<string> = string,
  TAccountClusterAccount extends string | AccountMeta<string> = string,
  TAccountInstructionsSysvar extends string | AccountMeta<string> =
    'Sysvar1nstructions1111111111111111111111111',
  TAccountRegularEncryptedTokenAccount extends string | AccountMeta<string> =
    string,
  TAccountEphemeralEncryptedTokenAccount extends string | AccountMeta<string> =
    string,
  TAccountRentRecipient extends string | AccountMeta<string> = string,
  TAccountRegularEncryptedTokenAta extends string | AccountMeta<string> =
    string,
  TAccountEphemeralEncryptedTokenAta extends string | AccountMeta<string> =
    string,
  TAccountTokenMint extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountArciumProgram extends string
        ? ReadonlyAccount<TAccountArciumProgram>
        : TAccountArciumProgram,
      TAccountCompDefAccount extends string
        ? ReadonlyAccount<TAccountCompDefAccount>
        : TAccountCompDefAccount,
      TAccountMxeAccount extends string
        ? ReadonlyAccount<TAccountMxeAccount>
        : TAccountMxeAccount,
      TAccountComputationAccount extends string
        ? ReadonlyAccount<TAccountComputationAccount>
        : TAccountComputationAccount,
      TAccountClusterAccount extends string
        ? ReadonlyAccount<TAccountClusterAccount>
        : TAccountClusterAccount,
      TAccountInstructionsSysvar extends string
        ? ReadonlyAccount<TAccountInstructionsSysvar>
        : TAccountInstructionsSysvar,
      TAccountRegularEncryptedTokenAccount extends string
        ? WritableAccount<TAccountRegularEncryptedTokenAccount>
        : TAccountRegularEncryptedTokenAccount,
      TAccountEphemeralEncryptedTokenAccount extends string
        ? WritableAccount<TAccountEphemeralEncryptedTokenAccount>
        : TAccountEphemeralEncryptedTokenAccount,
      TAccountRentRecipient extends string
        ? WritableAccount<TAccountRentRecipient>
        : TAccountRentRecipient,
      TAccountRegularEncryptedTokenAta extends string
        ? WritableAccount<TAccountRegularEncryptedTokenAta>
        : TAccountRegularEncryptedTokenAta,
      TAccountEphemeralEncryptedTokenAta extends string
        ? WritableAccount<TAccountEphemeralEncryptedTokenAta>
        : TAccountEphemeralEncryptedTokenAta,
      TAccountTokenMint extends string
        ? ReadonlyAccount<TAccountTokenMint>
        : TAccountTokenMint,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type CloseEphemeralEncryptedTokenAccountCallbackInstructionData = {
  discriminator: ReadonlyUint8Array;
  output:
    | {
        __kind: 'Success';
        fields: readonly [
          CloseEphemeralEncryptedTokenAccountOutput,
          Array<number>,
        ];
      }
    | { __kind: 'Failure' }
    | {
        __kind: 'MarkerForIdlBuildDoNotUseThis';
        fields: readonly [CloseEphemeralEncryptedTokenAccountOutput];
      };
};

export type CloseEphemeralEncryptedTokenAccountCallbackInstructionDataArgs = {
  output:
    | {
        __kind: 'Success';
        fields: readonly [
          CloseEphemeralEncryptedTokenAccountOutputArgs,
          Array<number>,
        ];
      }
    | { __kind: 'Failure' }
    | {
        __kind: 'MarkerForIdlBuildDoNotUseThis';
        fields: readonly [CloseEphemeralEncryptedTokenAccountOutputArgs];
      };
};

export function getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataEncoder(): Encoder<CloseEphemeralEncryptedTokenAccountCallbackInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      [
        'output',
        getDiscriminatedUnionEncoder([
          [
            'Success',
            getStructEncoder([
              [
                'fields',
                getTupleEncoder([
                  getCloseEphemeralEncryptedTokenAccountOutputEncoder(),
                  getArrayEncoder(getU8Encoder(), { size: 64 }),
                ]),
              ],
            ]),
          ],
          ['Failure', getUnitEncoder()],
          [
            'MarkerForIdlBuildDoNotUseThis',
            getStructEncoder([
              [
                'fields',
                getTupleEncoder([
                  getCloseEphemeralEncryptedTokenAccountOutputEncoder(),
                ]),
              ],
            ]),
          ],
        ]),
      ],
    ]),
    (value) => ({
      ...value,
      discriminator:
        CLOSE_EPHEMERAL_ENCRYPTED_TOKEN_ACCOUNT_CALLBACK_DISCRIMINATOR,
    })
  );
}

export function getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataDecoder(): Decoder<CloseEphemeralEncryptedTokenAccountCallbackInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    [
      'output',
      getDiscriminatedUnionDecoder([
        [
          'Success',
          getStructDecoder([
            [
              'fields',
              getTupleDecoder([
                getCloseEphemeralEncryptedTokenAccountOutputDecoder(),
                getArrayDecoder(getU8Decoder(), { size: 64 }),
              ]),
            ],
          ]),
        ],
        ['Failure', getUnitDecoder()],
        [
          'MarkerForIdlBuildDoNotUseThis',
          getStructDecoder([
            [
              'fields',
              getTupleDecoder([
                getCloseEphemeralEncryptedTokenAccountOutputDecoder(),
              ]),
            ],
          ]),
        ],
      ]),
    ],
  ]);
}

export function getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataCodec(): Codec<
  CloseEphemeralEncryptedTokenAccountCallbackInstructionDataArgs,
  CloseEphemeralEncryptedTokenAccountCallbackInstructionData
> {
  return combineCodec(
    getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataEncoder(),
    getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataDecoder()
  );
}

export type CloseEphemeralEncryptedTokenAccountCallbackInput<
  TAccountArciumProgram extends string = string,
  TAccountCompDefAccount extends string = string,
  TAccountMxeAccount extends string = string,
  TAccountComputationAccount extends string = string,
  TAccountClusterAccount extends string = string,
  TAccountInstructionsSysvar extends string = string,
  TAccountRegularEncryptedTokenAccount extends string = string,
  TAccountEphemeralEncryptedTokenAccount extends string = string,
  TAccountRentRecipient extends string = string,
  TAccountRegularEncryptedTokenAta extends string = string,
  TAccountEphemeralEncryptedTokenAta extends string = string,
  TAccountTokenMint extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  arciumProgram?: Address<TAccountArciumProgram>;
  compDefAccount: Address<TAccountCompDefAccount>;
  mxeAccount: Address<TAccountMxeAccount>;
  computationAccount: Address<TAccountComputationAccount>;
  clusterAccount: Address<TAccountClusterAccount>;
  instructionsSysvar?: Address<TAccountInstructionsSysvar>;
  regularEncryptedTokenAccount: Address<TAccountRegularEncryptedTokenAccount>;
  ephemeralEncryptedTokenAccount: Address<TAccountEphemeralEncryptedTokenAccount>;
  rentRecipient: Address<TAccountRentRecipient>;
  /** Regular ETA's ATA (destination for any SPL tokens) */
  regularEncryptedTokenAta: Address<TAccountRegularEncryptedTokenAta>;
  /** Ephemeral ETA's ATA (source of any SPL tokens, will be closed) */
  ephemeralEncryptedTokenAta: Address<TAccountEphemeralEncryptedTokenAta>;
  /** Token mint for transfer_checked */
  tokenMint: Address<TAccountTokenMint>;
  /** Token program for CPI */
  tokenProgram: Address<TAccountTokenProgram>;
  output: CloseEphemeralEncryptedTokenAccountCallbackInstructionDataArgs['output'];
};

export function getCloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TAccountArciumProgram extends string,
  TAccountCompDefAccount extends string,
  TAccountMxeAccount extends string,
  TAccountComputationAccount extends string,
  TAccountClusterAccount extends string,
  TAccountInstructionsSysvar extends string,
  TAccountRegularEncryptedTokenAccount extends string,
  TAccountEphemeralEncryptedTokenAccount extends string,
  TAccountRentRecipient extends string,
  TAccountRegularEncryptedTokenAta extends string,
  TAccountEphemeralEncryptedTokenAta extends string,
  TAccountTokenMint extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
>(
  input: CloseEphemeralEncryptedTokenAccountCallbackInput<
    TAccountArciumProgram,
    TAccountCompDefAccount,
    TAccountMxeAccount,
    TAccountComputationAccount,
    TAccountClusterAccount,
    TAccountInstructionsSysvar,
    TAccountRegularEncryptedTokenAccount,
    TAccountEphemeralEncryptedTokenAccount,
    TAccountRentRecipient,
    TAccountRegularEncryptedTokenAta,
    TAccountEphemeralEncryptedTokenAta,
    TAccountTokenMint,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): CloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TProgramAddress,
  TAccountArciumProgram,
  TAccountCompDefAccount,
  TAccountMxeAccount,
  TAccountComputationAccount,
  TAccountClusterAccount,
  TAccountInstructionsSysvar,
  TAccountRegularEncryptedTokenAccount,
  TAccountEphemeralEncryptedTokenAccount,
  TAccountRentRecipient,
  TAccountRegularEncryptedTokenAta,
  TAccountEphemeralEncryptedTokenAta,
  TAccountTokenMint,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPPORTUNITY_MARKET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    arciumProgram: { value: input.arciumProgram ?? null, isWritable: false },
    compDefAccount: { value: input.compDefAccount ?? null, isWritable: false },
    mxeAccount: { value: input.mxeAccount ?? null, isWritable: false },
    computationAccount: {
      value: input.computationAccount ?? null,
      isWritable: false,
    },
    clusterAccount: { value: input.clusterAccount ?? null, isWritable: false },
    instructionsSysvar: {
      value: input.instructionsSysvar ?? null,
      isWritable: false,
    },
    regularEncryptedTokenAccount: {
      value: input.regularEncryptedTokenAccount ?? null,
      isWritable: true,
    },
    ephemeralEncryptedTokenAccount: {
      value: input.ephemeralEncryptedTokenAccount ?? null,
      isWritable: true,
    },
    rentRecipient: { value: input.rentRecipient ?? null, isWritable: true },
    regularEncryptedTokenAta: {
      value: input.regularEncryptedTokenAta ?? null,
      isWritable: true,
    },
    ephemeralEncryptedTokenAta: {
      value: input.ephemeralEncryptedTokenAta ?? null,
      isWritable: true,
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.arciumProgram.value) {
    accounts.arciumProgram.value =
      'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ' as Address<'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ'>;
  }
  if (!accounts.instructionsSysvar.value) {
    accounts.instructionsSysvar.value =
      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.arciumProgram),
      getAccountMeta(accounts.compDefAccount),
      getAccountMeta(accounts.mxeAccount),
      getAccountMeta(accounts.computationAccount),
      getAccountMeta(accounts.clusterAccount),
      getAccountMeta(accounts.instructionsSysvar),
      getAccountMeta(accounts.regularEncryptedTokenAccount),
      getAccountMeta(accounts.ephemeralEncryptedTokenAccount),
      getAccountMeta(accounts.rentRecipient),
      getAccountMeta(accounts.regularEncryptedTokenAta),
      getAccountMeta(accounts.ephemeralEncryptedTokenAta),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataEncoder().encode(
      args as CloseEphemeralEncryptedTokenAccountCallbackInstructionDataArgs
    ),
    programAddress,
  } as CloseEphemeralEncryptedTokenAccountCallbackInstruction<
    TProgramAddress,
    TAccountArciumProgram,
    TAccountCompDefAccount,
    TAccountMxeAccount,
    TAccountComputationAccount,
    TAccountClusterAccount,
    TAccountInstructionsSysvar,
    TAccountRegularEncryptedTokenAccount,
    TAccountEphemeralEncryptedTokenAccount,
    TAccountRentRecipient,
    TAccountRegularEncryptedTokenAta,
    TAccountEphemeralEncryptedTokenAta,
    TAccountTokenMint,
    TAccountTokenProgram
  >);
}

export type ParsedCloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    arciumProgram: TAccountMetas[0];
    compDefAccount: TAccountMetas[1];
    mxeAccount: TAccountMetas[2];
    computationAccount: TAccountMetas[3];
    clusterAccount: TAccountMetas[4];
    instructionsSysvar: TAccountMetas[5];
    regularEncryptedTokenAccount: TAccountMetas[6];
    ephemeralEncryptedTokenAccount: TAccountMetas[7];
    rentRecipient: TAccountMetas[8];
    /** Regular ETA's ATA (destination for any SPL tokens) */
    regularEncryptedTokenAta: TAccountMetas[9];
    /** Ephemeral ETA's ATA (source of any SPL tokens, will be closed) */
    ephemeralEncryptedTokenAta: TAccountMetas[10];
    /** Token mint for transfer_checked */
    tokenMint: TAccountMetas[11];
    /** Token program for CPI */
    tokenProgram: TAccountMetas[12];
  };
  data: CloseEphemeralEncryptedTokenAccountCallbackInstructionData;
};

export function parseCloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCloseEphemeralEncryptedTokenAccountCallbackInstruction<
  TProgram,
  TAccountMetas
> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      arciumProgram: getNextAccount(),
      compDefAccount: getNextAccount(),
      mxeAccount: getNextAccount(),
      computationAccount: getNextAccount(),
      clusterAccount: getNextAccount(),
      instructionsSysvar: getNextAccount(),
      regularEncryptedTokenAccount: getNextAccount(),
      ephemeralEncryptedTokenAccount: getNextAccount(),
      rentRecipient: getNextAccount(),
      regularEncryptedTokenAta: getNextAccount(),
      ephemeralEncryptedTokenAta: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getCloseEphemeralEncryptedTokenAccountCallbackInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
