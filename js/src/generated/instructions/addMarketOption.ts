/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { OPPORTUNITY_MARKET_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const ADD_MARKET_OPTION_DISCRIMINATOR = new Uint8Array([
  76, 189, 93, 144, 50, 229, 250, 116,
]);

export function getAddMarketOptionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    ADD_MARKET_OPTION_DISCRIMINATOR
  );
}

export type AddMarketOptionInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountCreator extends string | AccountMeta<string> = string,
  TAccountMarket extends string | AccountMeta<string> = string,
  TAccountCentralState extends string | AccountMeta<string> = string,
  TAccountOption extends string | AccountMeta<string> = string,
  TAccountSourceVta extends string | AccountMeta<string> = string,
  TAccountLockedVta extends string | AccountMeta<string> = string,
  TAccountSignPdaAccount extends string | AccountMeta<string> = string,
  TAccountMxeAccount extends string | AccountMeta<string> = string,
  TAccountMempoolAccount extends string | AccountMeta<string> = string,
  TAccountExecutingPool extends string | AccountMeta<string> = string,
  TAccountComputationAccount extends string | AccountMeta<string> = string,
  TAccountCompDefAccount extends string | AccountMeta<string> = string,
  TAccountClusterAccount extends string | AccountMeta<string> = string,
  TAccountPoolAccount extends string | AccountMeta<string> =
    'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC',
  TAccountClockAccount extends string | AccountMeta<string> =
    '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot',
  TAccountSystemProgram extends string | AccountMeta<string> =
    '11111111111111111111111111111111',
  TAccountArciumProgram extends string | AccountMeta<string> =
    'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCreator extends string
        ? WritableSignerAccount<TAccountCreator> &
            AccountSignerMeta<TAccountCreator>
        : TAccountCreator,
      TAccountMarket extends string
        ? WritableAccount<TAccountMarket>
        : TAccountMarket,
      TAccountCentralState extends string
        ? ReadonlyAccount<TAccountCentralState>
        : TAccountCentralState,
      TAccountOption extends string
        ? WritableAccount<TAccountOption>
        : TAccountOption,
      TAccountSourceVta extends string
        ? ReadonlyAccount<TAccountSourceVta>
        : TAccountSourceVta,
      TAccountLockedVta extends string
        ? WritableAccount<TAccountLockedVta>
        : TAccountLockedVta,
      TAccountSignPdaAccount extends string
        ? WritableAccount<TAccountSignPdaAccount>
        : TAccountSignPdaAccount,
      TAccountMxeAccount extends string
        ? ReadonlyAccount<TAccountMxeAccount>
        : TAccountMxeAccount,
      TAccountMempoolAccount extends string
        ? WritableAccount<TAccountMempoolAccount>
        : TAccountMempoolAccount,
      TAccountExecutingPool extends string
        ? WritableAccount<TAccountExecutingPool>
        : TAccountExecutingPool,
      TAccountComputationAccount extends string
        ? WritableAccount<TAccountComputationAccount>
        : TAccountComputationAccount,
      TAccountCompDefAccount extends string
        ? ReadonlyAccount<TAccountCompDefAccount>
        : TAccountCompDefAccount,
      TAccountClusterAccount extends string
        ? WritableAccount<TAccountClusterAccount>
        : TAccountClusterAccount,
      TAccountPoolAccount extends string
        ? WritableAccount<TAccountPoolAccount>
        : TAccountPoolAccount,
      TAccountClockAccount extends string
        ? WritableAccount<TAccountClockAccount>
        : TAccountClockAccount,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountArciumProgram extends string
        ? ReadonlyAccount<TAccountArciumProgram>
        : TAccountArciumProgram,
      ...TRemainingAccounts,
    ]
  >;

export type AddMarketOptionInstructionData = {
  discriminator: ReadonlyUint8Array;
  computationOffset: bigint;
  optionIndex: number;
  name: string;
  amount: bigint;
  userPubkey: Array<number>;
  lockedVtaNonce: bigint;
};

export type AddMarketOptionInstructionDataArgs = {
  computationOffset: number | bigint;
  optionIndex: number;
  name: string;
  amount: number | bigint;
  userPubkey: Array<number>;
  lockedVtaNonce: number | bigint;
};

export function getAddMarketOptionInstructionDataEncoder(): Encoder<AddMarketOptionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['computationOffset', getU64Encoder()],
      ['optionIndex', getU16Encoder()],
      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ['amount', getU64Encoder()],
      ['userPubkey', getArrayEncoder(getU8Encoder(), { size: 32 })],
      ['lockedVtaNonce', getU128Encoder()],
    ]),
    (value) => ({ ...value, discriminator: ADD_MARKET_OPTION_DISCRIMINATOR })
  );
}

export function getAddMarketOptionInstructionDataDecoder(): Decoder<AddMarketOptionInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['computationOffset', getU64Decoder()],
    ['optionIndex', getU16Decoder()],
    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ['amount', getU64Decoder()],
    ['userPubkey', getArrayDecoder(getU8Decoder(), { size: 32 })],
    ['lockedVtaNonce', getU128Decoder()],
  ]);
}

export function getAddMarketOptionInstructionDataCodec(): Codec<
  AddMarketOptionInstructionDataArgs,
  AddMarketOptionInstructionData
> {
  return combineCodec(
    getAddMarketOptionInstructionDataEncoder(),
    getAddMarketOptionInstructionDataDecoder()
  );
}

export type AddMarketOptionAsyncInput<
  TAccountCreator extends string = string,
  TAccountMarket extends string = string,
  TAccountCentralState extends string = string,
  TAccountOption extends string = string,
  TAccountSourceVta extends string = string,
  TAccountLockedVta extends string = string,
  TAccountSignPdaAccount extends string = string,
  TAccountMxeAccount extends string = string,
  TAccountMempoolAccount extends string = string,
  TAccountExecutingPool extends string = string,
  TAccountComputationAccount extends string = string,
  TAccountCompDefAccount extends string = string,
  TAccountClusterAccount extends string = string,
  TAccountPoolAccount extends string = string,
  TAccountClockAccount extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountArciumProgram extends string = string,
> = {
  creator: TransactionSigner<TAccountCreator>;
  market: Address<TAccountMarket>;
  centralState?: Address<TAccountCentralState>;
  option?: Address<TAccountOption>;
  sourceVta: Address<TAccountSourceVta>;
  lockedVta: Address<TAccountLockedVta>;
  signPdaAccount?: Address<TAccountSignPdaAccount>;
  mxeAccount: Address<TAccountMxeAccount>;
  mempoolAccount: Address<TAccountMempoolAccount>;
  executingPool: Address<TAccountExecutingPool>;
  computationAccount: Address<TAccountComputationAccount>;
  compDefAccount: Address<TAccountCompDefAccount>;
  clusterAccount: Address<TAccountClusterAccount>;
  poolAccount?: Address<TAccountPoolAccount>;
  clockAccount?: Address<TAccountClockAccount>;
  systemProgram?: Address<TAccountSystemProgram>;
  arciumProgram?: Address<TAccountArciumProgram>;
  computationOffset: AddMarketOptionInstructionDataArgs['computationOffset'];
  optionIndex: AddMarketOptionInstructionDataArgs['optionIndex'];
  name: AddMarketOptionInstructionDataArgs['name'];
  amount: AddMarketOptionInstructionDataArgs['amount'];
  userPubkey: AddMarketOptionInstructionDataArgs['userPubkey'];
  lockedVtaNonce: AddMarketOptionInstructionDataArgs['lockedVtaNonce'];
};

export async function getAddMarketOptionInstructionAsync<
  TAccountCreator extends string,
  TAccountMarket extends string,
  TAccountCentralState extends string,
  TAccountOption extends string,
  TAccountSourceVta extends string,
  TAccountLockedVta extends string,
  TAccountSignPdaAccount extends string,
  TAccountMxeAccount extends string,
  TAccountMempoolAccount extends string,
  TAccountExecutingPool extends string,
  TAccountComputationAccount extends string,
  TAccountCompDefAccount extends string,
  TAccountClusterAccount extends string,
  TAccountPoolAccount extends string,
  TAccountClockAccount extends string,
  TAccountSystemProgram extends string,
  TAccountArciumProgram extends string,
  TProgramAddress extends Address = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
>(
  input: AddMarketOptionAsyncInput<
    TAccountCreator,
    TAccountMarket,
    TAccountCentralState,
    TAccountOption,
    TAccountSourceVta,
    TAccountLockedVta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountArciumProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  AddMarketOptionInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountMarket,
    TAccountCentralState,
    TAccountOption,
    TAccountSourceVta,
    TAccountLockedVta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountArciumProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPPORTUNITY_MARKET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: true },
    market: { value: input.market ?? null, isWritable: true },
    centralState: { value: input.centralState ?? null, isWritable: false },
    option: { value: input.option ?? null, isWritable: true },
    sourceVta: { value: input.sourceVta ?? null, isWritable: false },
    lockedVta: { value: input.lockedVta ?? null, isWritable: true },
    signPdaAccount: { value: input.signPdaAccount ?? null, isWritable: true },
    mxeAccount: { value: input.mxeAccount ?? null, isWritable: false },
    mempoolAccount: { value: input.mempoolAccount ?? null, isWritable: true },
    executingPool: { value: input.executingPool ?? null, isWritable: true },
    computationAccount: {
      value: input.computationAccount ?? null,
      isWritable: true,
    },
    compDefAccount: { value: input.compDefAccount ?? null, isWritable: false },
    clusterAccount: { value: input.clusterAccount ?? null, isWritable: true },
    poolAccount: { value: input.poolAccount ?? null, isWritable: true },
    clockAccount: { value: input.clockAccount ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    arciumProgram: { value: input.arciumProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.centralState.value) {
    accounts.centralState.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            99, 101, 110, 116, 114, 97, 108, 95, 115, 116, 97, 116, 101,
          ])
        ),
      ],
    });
  }
  if (!accounts.option.value) {
    accounts.option.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([111, 112, 116, 105, 111, 110])
        ),
        getAddressEncoder().encode(expectAddress(accounts.market.value)),
        getU16Encoder().encode(expectSome(args.optionIndex)),
      ],
    });
  }
  if (!accounts.signPdaAccount.value) {
    accounts.signPdaAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            65, 114, 99, 105, 117, 109, 83, 105, 103, 110, 101, 114, 65, 99, 99,
            111, 117, 110, 116,
          ])
        ),
      ],
    });
  }
  if (!accounts.poolAccount.value) {
    accounts.poolAccount.value =
      'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC' as Address<'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC'>;
  }
  if (!accounts.clockAccount.value) {
    accounts.clockAccount.value =
      '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot' as Address<'7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.arciumProgram.value) {
    accounts.arciumProgram.value =
      'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ' as Address<'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.market),
      getAccountMeta(accounts.centralState),
      getAccountMeta(accounts.option),
      getAccountMeta(accounts.sourceVta),
      getAccountMeta(accounts.lockedVta),
      getAccountMeta(accounts.signPdaAccount),
      getAccountMeta(accounts.mxeAccount),
      getAccountMeta(accounts.mempoolAccount),
      getAccountMeta(accounts.executingPool),
      getAccountMeta(accounts.computationAccount),
      getAccountMeta(accounts.compDefAccount),
      getAccountMeta(accounts.clusterAccount),
      getAccountMeta(accounts.poolAccount),
      getAccountMeta(accounts.clockAccount),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.arciumProgram),
    ],
    data: getAddMarketOptionInstructionDataEncoder().encode(
      args as AddMarketOptionInstructionDataArgs
    ),
    programAddress,
  } as AddMarketOptionInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountMarket,
    TAccountCentralState,
    TAccountOption,
    TAccountSourceVta,
    TAccountLockedVta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountArciumProgram
  >);
}

export type AddMarketOptionInput<
  TAccountCreator extends string = string,
  TAccountMarket extends string = string,
  TAccountCentralState extends string = string,
  TAccountOption extends string = string,
  TAccountSourceVta extends string = string,
  TAccountLockedVta extends string = string,
  TAccountSignPdaAccount extends string = string,
  TAccountMxeAccount extends string = string,
  TAccountMempoolAccount extends string = string,
  TAccountExecutingPool extends string = string,
  TAccountComputationAccount extends string = string,
  TAccountCompDefAccount extends string = string,
  TAccountClusterAccount extends string = string,
  TAccountPoolAccount extends string = string,
  TAccountClockAccount extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountArciumProgram extends string = string,
> = {
  creator: TransactionSigner<TAccountCreator>;
  market: Address<TAccountMarket>;
  centralState: Address<TAccountCentralState>;
  option: Address<TAccountOption>;
  sourceVta: Address<TAccountSourceVta>;
  lockedVta: Address<TAccountLockedVta>;
  signPdaAccount: Address<TAccountSignPdaAccount>;
  mxeAccount: Address<TAccountMxeAccount>;
  mempoolAccount: Address<TAccountMempoolAccount>;
  executingPool: Address<TAccountExecutingPool>;
  computationAccount: Address<TAccountComputationAccount>;
  compDefAccount: Address<TAccountCompDefAccount>;
  clusterAccount: Address<TAccountClusterAccount>;
  poolAccount?: Address<TAccountPoolAccount>;
  clockAccount?: Address<TAccountClockAccount>;
  systemProgram?: Address<TAccountSystemProgram>;
  arciumProgram?: Address<TAccountArciumProgram>;
  computationOffset: AddMarketOptionInstructionDataArgs['computationOffset'];
  optionIndex: AddMarketOptionInstructionDataArgs['optionIndex'];
  name: AddMarketOptionInstructionDataArgs['name'];
  amount: AddMarketOptionInstructionDataArgs['amount'];
  userPubkey: AddMarketOptionInstructionDataArgs['userPubkey'];
  lockedVtaNonce: AddMarketOptionInstructionDataArgs['lockedVtaNonce'];
};

export function getAddMarketOptionInstruction<
  TAccountCreator extends string,
  TAccountMarket extends string,
  TAccountCentralState extends string,
  TAccountOption extends string,
  TAccountSourceVta extends string,
  TAccountLockedVta extends string,
  TAccountSignPdaAccount extends string,
  TAccountMxeAccount extends string,
  TAccountMempoolAccount extends string,
  TAccountExecutingPool extends string,
  TAccountComputationAccount extends string,
  TAccountCompDefAccount extends string,
  TAccountClusterAccount extends string,
  TAccountPoolAccount extends string,
  TAccountClockAccount extends string,
  TAccountSystemProgram extends string,
  TAccountArciumProgram extends string,
  TProgramAddress extends Address = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
>(
  input: AddMarketOptionInput<
    TAccountCreator,
    TAccountMarket,
    TAccountCentralState,
    TAccountOption,
    TAccountSourceVta,
    TAccountLockedVta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountArciumProgram
  >,
  config?: { programAddress?: TProgramAddress }
): AddMarketOptionInstruction<
  TProgramAddress,
  TAccountCreator,
  TAccountMarket,
  TAccountCentralState,
  TAccountOption,
  TAccountSourceVta,
  TAccountLockedVta,
  TAccountSignPdaAccount,
  TAccountMxeAccount,
  TAccountMempoolAccount,
  TAccountExecutingPool,
  TAccountComputationAccount,
  TAccountCompDefAccount,
  TAccountClusterAccount,
  TAccountPoolAccount,
  TAccountClockAccount,
  TAccountSystemProgram,
  TAccountArciumProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? OPPORTUNITY_MARKET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: true },
    market: { value: input.market ?? null, isWritable: true },
    centralState: { value: input.centralState ?? null, isWritable: false },
    option: { value: input.option ?? null, isWritable: true },
    sourceVta: { value: input.sourceVta ?? null, isWritable: false },
    lockedVta: { value: input.lockedVta ?? null, isWritable: true },
    signPdaAccount: { value: input.signPdaAccount ?? null, isWritable: true },
    mxeAccount: { value: input.mxeAccount ?? null, isWritable: false },
    mempoolAccount: { value: input.mempoolAccount ?? null, isWritable: true },
    executingPool: { value: input.executingPool ?? null, isWritable: true },
    computationAccount: {
      value: input.computationAccount ?? null,
      isWritable: true,
    },
    compDefAccount: { value: input.compDefAccount ?? null, isWritable: false },
    clusterAccount: { value: input.clusterAccount ?? null, isWritable: true },
    poolAccount: { value: input.poolAccount ?? null, isWritable: true },
    clockAccount: { value: input.clockAccount ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    arciumProgram: { value: input.arciumProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.poolAccount.value) {
    accounts.poolAccount.value =
      'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC' as Address<'G2sRWJvi3xoyh5k2gY49eG9L8YhAEWQPtNb1zb1GXTtC'>;
  }
  if (!accounts.clockAccount.value) {
    accounts.clockAccount.value =
      '7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot' as Address<'7EbMUTLo5DjdzbN7s8BXeZwXzEwNQb1hScfRvWg8a6ot'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.arciumProgram.value) {
    accounts.arciumProgram.value =
      'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ' as Address<'Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.market),
      getAccountMeta(accounts.centralState),
      getAccountMeta(accounts.option),
      getAccountMeta(accounts.sourceVta),
      getAccountMeta(accounts.lockedVta),
      getAccountMeta(accounts.signPdaAccount),
      getAccountMeta(accounts.mxeAccount),
      getAccountMeta(accounts.mempoolAccount),
      getAccountMeta(accounts.executingPool),
      getAccountMeta(accounts.computationAccount),
      getAccountMeta(accounts.compDefAccount),
      getAccountMeta(accounts.clusterAccount),
      getAccountMeta(accounts.poolAccount),
      getAccountMeta(accounts.clockAccount),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.arciumProgram),
    ],
    data: getAddMarketOptionInstructionDataEncoder().encode(
      args as AddMarketOptionInstructionDataArgs
    ),
    programAddress,
  } as AddMarketOptionInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountMarket,
    TAccountCentralState,
    TAccountOption,
    TAccountSourceVta,
    TAccountLockedVta,
    TAccountSignPdaAccount,
    TAccountMxeAccount,
    TAccountMempoolAccount,
    TAccountExecutingPool,
    TAccountComputationAccount,
    TAccountCompDefAccount,
    TAccountClusterAccount,
    TAccountPoolAccount,
    TAccountClockAccount,
    TAccountSystemProgram,
    TAccountArciumProgram
  >);
}

export type ParsedAddMarketOptionInstruction<
  TProgram extends string = typeof OPPORTUNITY_MARKET_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    creator: TAccountMetas[0];
    market: TAccountMetas[1];
    centralState: TAccountMetas[2];
    option: TAccountMetas[3];
    sourceVta: TAccountMetas[4];
    lockedVta: TAccountMetas[5];
    signPdaAccount: TAccountMetas[6];
    mxeAccount: TAccountMetas[7];
    mempoolAccount: TAccountMetas[8];
    executingPool: TAccountMetas[9];
    computationAccount: TAccountMetas[10];
    compDefAccount: TAccountMetas[11];
    clusterAccount: TAccountMetas[12];
    poolAccount: TAccountMetas[13];
    clockAccount: TAccountMetas[14];
    systemProgram: TAccountMetas[15];
    arciumProgram: TAccountMetas[16];
  };
  data: AddMarketOptionInstructionData;
};

export function parseAddMarketOptionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedAddMarketOptionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 17) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      creator: getNextAccount(),
      market: getNextAccount(),
      centralState: getNextAccount(),
      option: getNextAccount(),
      sourceVta: getNextAccount(),
      lockedVta: getNextAccount(),
      signPdaAccount: getNextAccount(),
      mxeAccount: getNextAccount(),
      mempoolAccount: getNextAccount(),
      executingPool: getNextAccount(),
      computationAccount: getNextAccount(),
      compDefAccount: getNextAccount(),
      clusterAccount: getNextAccount(),
      poolAccount: getNextAccount(),
      clockAccount: getNextAccount(),
      systemProgram: getNextAccount(),
      arciumProgram: getNextAccount(),
    },
    data: getAddMarketOptionInstructionDataDecoder().decode(instruction.data),
  };
}
